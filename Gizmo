-- Gizmo (Synapse Drawing remake, no attribute dependency)
-- Drop in executor and use like:
-- local gizmo = loadstring(<this code>)()
-- gizmo.drawLine(Vector3.new(0,5,0), Vector3.new(5,5,5))

local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local Drawing = Drawing -- Synapse-provided Drawing API

local gizmo = {}

-- Config/defaults
local POINT_SCALE = 5
local defaultColor = Color3.fromRGB(0, 170, 255)
local defaultThickness = 2
local defaultScale = 1

-- State
local properties = {
	Color3 = defaultColor,
	Transparency = 0,
}
local thickness = defaultThickness
local globalScale = defaultScale
local globalOrigin = CFrame.new(0,0,0)

-- Object pools
local cache = {
	Line = {},
	Triangle = {},
	Circle = {},
	Text = {},
	Square = {},
}
local activeDraws = {}
local queue = {}

-- helpers
local function getDraw(typeName)
	local pool = cache[typeName]
	local obj = table.remove(pool)
	if obj and obj.Remove then
		obj.Visible = true
		return obj
	end
	return Drawing.new(typeName)
end

local function releaseDraw(obj, typeName)
	if not obj then return end
	pcall(function()
		obj.Visible = false
		if obj.Remove then
			table.insert(cache[typeName], obj)
		end
	end)
end

local function project(pos)
	if not Camera then Camera = Workspace.CurrentCamera end
	local p, onScreen = Camera:WorldToViewportPoint(pos)
	return Vector2.new(p.X, p.Y), (onScreen and p.Z > 0), p.Z
end

local function applyStyle(draw, kind)
	if not draw then return end
	if kind == "Line" then
		draw.Color = properties.Color3
		draw.Transparency = 1 - (1 - properties.Transparency)
		draw.Thickness = thickness * globalScale
	elseif kind == "Triangle" then
		draw.Filled = true
		draw.Color = properties.Color3
		draw.Transparency = 1 - (1 - properties.Transparency)
	elseif kind == "Circle" then
		draw.Color = properties.Color3
		draw.Transparency = 1 - (1 - properties.Transparency)
		draw.Thickness = thickness * globalScale
	elseif kind == "Text" then
		draw.Color = properties.Color3
		draw.Transparency = 1 - (1 - properties.Transparency)
	elseif kind == "Square" then
		draw.Color = properties.Color3
		draw.Transparency = 1 - (1 - properties.Transparency)
		draw.Thickness = thickness * globalScale
	end
end

local function queuePrimitive(kind, args)
	table.insert(queue, {kind=kind, args=args})
end

-- Public API
function gizmo.setColor(color)
	if typeof(color) == "Color3" then
		properties.Color3 = color
	elseif typeof(color) == "string" then
		local hex = color:match("#?([A-Fa-f0-9]+)")
		if hex and (#hex == 6) then
			local r = tonumber(hex:sub(1,2),16)/255
			local g = tonumber(hex:sub(3,4),16)/255
			local b = tonumber(hex:sub(5,6),16)/255
			properties.Color3 = Color3.new(r,g,b)
		end
	else
		pcall(function()
			properties.Color3 = BrickColor.new(color).Color
		end)
	end
end

function gizmo.setColor3(c3)
	if typeof(c3) == "Color3" then properties.Color3 = c3 end
end

function gizmo.setOrigin(cf)
	if typeof(cf) == "CFrame" then globalOrigin = cf end
end

function gizmo.setTransparency(t)
	properties.Transparency = math.clamp(t or 0, 0, 1)
end

function gizmo.setScale(s)
	globalScale = s or 1
end

function gizmo.reset()
	properties.Transparency = 0
	thickness = defaultThickness
	properties.Color3 = defaultColor
	globalScale = defaultScale
	globalOrigin = CFrame.new(0,0,0)
end

function gizmo.clear()
	for _,d in ipairs(activeDraws) do
		if d._type then
			releaseDraw(d, d._type)
		else
			pcall(function() d.Visible = false end)
		end
	end
	activeDraws = {}
	queue = {}
end

-- Drawing primitives
function gizmo.drawPoint(position)
	if typeof(position) ~= "Vector3" then return end
	queuePrimitive("point", {pos = position})
end

function gizmo.drawLine(a,b)
	if typeof(a) ~= "Vector3" or typeof(b) ~= "Vector3" then return end
	queuePrimitive("line", {a=a,b=b})
end

function gizmo.drawArrow(a,b)
	if typeof(a) ~= "Vector3" or typeof(b) ~= "Vector3" then return end
	queuePrimitive("arrow", {a=a,b=b})
end

function gizmo.drawRay(from,dir)
	if typeof(from) ~= "Vector3" or typeof(dir) ~= "Vector3" then return end
	gizmo.drawArrow(from, from + dir)
end

function gizmo.drawText(pos,text,...)
	local safe = tostring(text)
	if select("#", ...) > 0 then
		safe = safe:format(...)
	end
	queuePrimitive("text", {pos=pos, text=safe})
end

function gizmo.drawSphere(cf, radius)
	if typeof(cf) ~= "CFrame" or typeof(radius) ~= "number" then return end
	queuePrimitive("sphere", {center=(globalOrigin * cf).Position, radius=radius})
end

function gizmo.drawWireSphere(cf, radius)
	if typeof(cf) ~= "CFrame" or typeof(radius) ~= "number" then return end
	queuePrimitive("wiresphere", {center=(globalOrigin * cf).Position, radius=radius})
end

function gizmo.drawBox(cf, size)
	if typeof(cf) ~= "CFrame" or typeof(size) ~= "Vector3" then return end
	local rel = globalOrigin * cf
	local hx, hy, hz = size.X/2, size.Y/2, size.Z/2
	local offsets = {
		Vector3.new( hx,  hy,  hz),
		Vector3.new( hx,  hy, -hz),
		Vector3.new( hx, -hy,  hz),
		Vector3.new( hx, -hy, -hz),
		Vector3.new(-hx,  hy,  hz),
		Vector3.new(-hx,  hy, -hz),
		Vector3.new(-hx, -hy,  hz),
		Vector3.new(-hx, -hy, -hz),
	}
	local corners = {}
	for i,off in ipairs(offsets) do
		corners[i] = (rel * CFrame.new(off)).Position
	end
	local edges = {
		{1,2},{1,3},{1,5},
		{8,7},{8,6},{8,4},
		{2,4},{2,6},
		{3,4},{3,7},
		{5,6},{5,7},
	}
	for _,e in ipairs(edges) do
		gizmo.drawLine(corners[e[1]], corners[e[2]])
	end
end

function gizmo.drawWireBox(cf, size)
	gizmo.drawBox(cf, size)
end

-- internal helper for arrow
local function drawArrow2D(a2,b2)
	local line = getDraw("Line")
	line.From = a2
	line.To = b2
	applyStyle(line, "Line")
	line._type = "Line"
	table.insert(activeDraws, line)

	local dir = (a2 - b2).Unit
	local side = Vector2.new(-dir.Y, dir.X)
	local headLen = math.clamp((a2 - b2).Magnitude * 0.15, 8, 30) * globalScale
	local p1 = b2
	local p2 = b2 + dir * headLen + side * (headLen * 0.6)
	local p3 = b2 + dir * headLen - side * (headLen * 0.6)
	local tri = getDraw("Triangle")
	tri.PointA, tri.PointB, tri.PointC = p1,p2,p3
	applyStyle(tri, "Triangle")
	tri._type = "Triangle"
	table.insert(activeDraws, tri)
end

-- render loop
local function renderStep()
	for _,d in ipairs(activeDraws) do
		if d._type then
			releaseDraw(d, d._type)
		else
			pcall(function() d.Visible = false end)
		end
	end
	activeDraws = {}

	for _,cmd in ipairs(queue) do
		local k,a = cmd.kind,cmd.args
		if k=="point" then
			local s,on = project(a.pos)
			if on then
				local dot = getDraw("Circle")
				dot.Position = s
				dot.Radius = math.max(1, (globalScale * thickness * POINT_SCALE) / 2)
				dot.Filled = true
				applyStyle(dot,"Circle")
				dot._type = "Circle"
				table.insert(activeDraws,dot)
			end
		elseif k=="line" then
			local sA,onA = project(a.a)
			local sB,onB = project(a.b)
			if onA and onB then
				local line = getDraw("Line")
				line.From = sA
				line.To = sB
				applyStyle(line,"Line")
				line._type = "Line"
				table.insert(activeDraws,line)
			end
		elseif k=="arrow" then
			local sA,onA = project(a.a)
			local sB,onB = project(a.b)
			if onA and onB then drawArrow2D(sA,sB) end
		elseif k=="text" then
			local s,on = project(a.pos)
			if on then
				local t = getDraw("Text")
				t.Position = s
				t.Text = tostring(a.text)
				t.Center = true
				t.Size = 14 * globalScale
				t.Font = Drawing.Fonts().Monospace or 3
				t.Outline = true
				t.OutlineColor = Color3.new(0,0,0)
				applyStyle(t,"Text")
				t._type = "Text"
				table.insert(activeDraws,t)
			end
		elseif k=="sphere" then
			local c=a.center
			local right=(Camera.CFrame.RightVector)*a.radius
			local sC,onC=project(c)
			local sR,onR=project(c+right)
			if onC and onR then
				local circ=getDraw("Circle")
				circ.Position=sC
				circ.Radius=(sR-sC).Magnitude
				circ.Filled=false
				circ.NumSides=32
				applyStyle(circ,"Circle")
				circ._type="Circle"
				table.insert(activeDraws,circ)
			end
		elseif k=="wiresphere" then
			local c=a.center
			local r=a.radius
			local axes={Camera.CFrame.RightVector,Camera.CFrame.UpVector,Camera.CFrame.LookVector}
			for _,ax in ipairs(axes) do
				local sC,onC=project(c)
				local sR,onR=project(c+ax*r)
				if onC and onR then
					local circ=getDraw("Circle")
					circ.Position=sC
					circ.Radius=(sR-sC).Magnitude
					circ.Filled=false
					circ.NumSides=32
					applyStyle(circ,"Circle")
					circ._type="Circle"
					table.insert(activeDraws,circ)
				end
			end
		end
	end

	queue = {}
end

RunService.RenderStepped:Connect(renderStep)

return gizmo
